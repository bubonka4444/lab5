"""1.	Формируется матрица F следующим образом: скопировать в нее А и если количество нулей в В больше, чем в Е,
то поменять в ней местами В и С симметрично, иначе В и Е поменять местами несимметрично. При этом матрица А не меняется.
 После чего если определитель матрицы А больше суммы диагональных элементов матрицы F, то вычисляется выражение: A*AT – K * F,
иначе вычисляется выражение (A-1 +G-F-1)*K, где G-нижняя треугольная матрица, полученная из А.
Выводятся по мере формирования А, F и все матричные операции последовательно. """

import numpy as np
import time
import random

N = int(input("Введите количество строк (столбцов) квадратной матрицы в интервале от 4 до 100: "))
while N < 4 or 100 < N:
    N = int(input("Введите количество строк (столбцов) квадратной матрицы в интервале от 4 до 100: "))

K = int(input("Введите число К: "))
start = time.time()

A = np.random.randint(-10, 10, (N, N)) #заполняем матрицу А случайными числами
print("Матрица А")
print(A)

F = A.copy()           #копируем элементы матрицы А в матрицу F
print("Матрица F")
print(F)

if np.count_nonzero(F[0: N//2: 1, 0: N//2: 1]) < np.count_nonzero(F[N//2: N:1, N//2: N: 1]):
    for i in range(N//2):
        for j in range(N//2):
            F[i][j + N//2 + N % 2], F[N - 1 - i][j + N//2 + N % 2] = F[N - 1 - i][j + N//2 + N % 2], F[i][j + N//2 + N % 2]
else:
    for i in range(N//2):
        for j in range(N//2):
            F[i][j], F[i][N // 2 + N % 2 + j] = F[i][N // 2 + N % 2 + j], F[i][j]
print("Матрица F")
print(F)

G = np.tril(A, k=0)             #формируем матрицу из нижнего тругольника матрицы А
print("Матрица G")
print(G)

if np.linalg.det(A) > np.trace(F):
    print("A*AT – K * F")
    print(np.dot(np.array(A),(np.transpose(A)))-K*F)
else:
    print("(A-1 +G-F-1)*K")
    print((np.linalg.inv(A)+G-(np.linalg.inv(F)))*K)

#B = F[0: N//2: 1, 0: N//2: 1]
#print("Матрица B")
#print(B)

#E = F[N//2: N: 1, N//2: N: 1]
#print("Матрица E")
#print(E)

#C = F[0: N//2: 1, N//2: N: 1]
#print("Матрица C")
#print(C)
